#+AUTHOR: Andrea Crotti
#+REVEAL_THEME: dracula
#+REVEAL_TRANS: fade
#+REVEAL_SPEED: fast
#+REVEAL_TOC: nil
#+OPTIONS: num:nil ^:nil tex:t toc:nil reveal_progress:t reveal_control:t
#+reveal_overview:t

#+title: Problem Solving
#+subtitle: For Software Engineers


* TODO check if we need the TOC or should get rid

* TODO think if the case studies are simple enough and add more information there

* TODO get rid of the slide numbers that's just not necessary

* TODO justify all the quotes from Sherlock Holmes

*  Problem solving
#+begin_notes
As software engineers, we are constantly solving problems. They can be as hard
as a subtle concurrency bug that takes a week to find, to just understanding why
a library is not behaving as you think it should.

This talk just concentrates on the hard problems and a method about how to tackle them.
I'm in no way an expert problem solver, but the reasons why I wanted to give this talk is because in my career I've spent an enormous amount of time solving hard problems, and in retrospect with a more methodic approach would have allowed me to go way faster and not stress as much.

As you will see from the next slides there are lots of Sherlock Holmes, who I think would have been a great software engineer, or at least a great debugging consultant.
Fun fact about the "Elementary, my dear Watson", these exact words are never used in Holmes stories, but it was paraphrased from the "Crooked Man", and it was “‘Excellent!’ I [Watson] cried. ‘Elementary,’ said he.”
#+end_notes

#+begin_quote
Elementary, my dear Watson' ~ Sherlock Holmes
#+end_quote


* The method

#+begin_notes
There are lots of books about problem solving, where probably the most famous is "How to solve it" a small volume written in 1945, which I read ages ago and gave me the idea for this talk.
That book in particular is quite focused on solving math problems, in this talk I just want to focus on software development so I just came up with some steps myself, from personal experience and other articles.
#+end_notes

** Don't

#+begin_notes
I will start with the things you should not do first.
Specially when the problem you are trying to solve is affecting production you might panic and just try to rush to find a solution.
Unfortunately that pretty much never helps and you if you don't think clearly you might just end up wasting a lot of time following the wrong lead, and make the situation even worse.
For the same reason you should not try to guess without enough evidence.
Lastly avoid pointing fingers, blaming the last person who deployed a change might just be wrong and will just put the other person on the defensive.
#+end_notes

- don't panic
- don't rush
- don't guess
- don't blame

** Describe the problem

#+begin_notes
The first phase is actually describing the problem and collecting all the evidence.
This is probably the most important phase and maybe the most neglected one, even by senior developers.
In this phase you should collect all the evidence and write down a detailed description of the problem.
#+end_notes

#+begin_quote
“Data! Data! Data!” he cried impatiently. “I can’t make bricks without clay.” ~ Sherlock Holmes
#+end_quote

- gather as much data as possible
  - when did the problem happen first?
  - how often is it happening?
  - what did we change?
  - have any of the external dependencies changed?
- *write it all down*

** Reproduce

#+begin_notes
This phase is maybe the hardest one, since sometimes you can't really reproduce easily a production issue.
It's also very important though because if you can't reproduce a problem, it will be a lot harder to know if you actually fixed it or not.
So try to reproduce the problem locally, even better if you can write a failing test.
If it turns out that you really can't reproduce the problem at all then that's also very valuable information, since it probably means that it's not something under your control that's causing the software to misbehave.

#+end_notes

#+begin_quote
‘You see, but you do not observe. The distinction is clear.’ ~ Sherlock Holmes
#+end_quote

- can you reproduce the problem?
- can you write a failing test?

** Fix it

#+begin_notes
At this stage hopefully we know what the problem is, and we can really go about at fixing it.
This phase can take quite a long time depending on how easily you can reproduce the problem, but the main takeaways here are that you really need to change one thing at a time.
In this phase is also very important to keep track of all the attempts you've made, specially if it's an extremely difficult problem to solve and can take days, you'll be grateful to have it all written down.
#+end_notes

#+BEGIN_QUOTE
“When you have eliminated all which is impossible, then whatever remains, however improbable, must be the truth.” ~ Sherlock Holmes
#+END_QUOTE

- history is your friend
- change *ONE VARIABLE AT A TIME*?
- keep track of all your attempts
- test your fix in the real environment

** Are we done yet?

#+begin_notes
Assuming you
#+end_notes

#+begin_quote
“Those who cannot remember the past are condemned to repeat it.” ~ George Santayana
#+end_quote

- is the problem really gone?
- are you sure it can't happen again?
- what else can you do to make the system more resilient/transparent?

* Examples

** A slow request

- moved an API from http to HTTPS
- the API got unbearably slow
- no code changed
- what is going on?

#+REVEAL: split

#+begin_src clojure
(declare heavy-transformations)

(defn do-lots-of-smart-stuff [request]
  (let [ts (cf/parse (-> request :json-params :ts))]
    (heavy-transformations (request))))
#+end_src

|--------------------------------------------+---------|
| fn                                         | max time |
|--------------------------------------------+---------|
| :clojure-debugging.speedy/defn_without-fmt | 21.22μs |
| :clojure-debugging.speedy/defn_with-fmt    | 53.34μs |

** A question of space

- kafka connect workers stop working
- no code changed
- no useful logs anywhere
- the process is still running, it just hangs forever

#+REVEAL: split

#+begin_src clojure
(defn store-files!
  [{:keys [file-writing-pool] :as ctx}
   {:keys [batch-id] :as batch}]
  (log/log "Storing files" {:batch-id batch-id})
  (cp/future file-writing-pool
             (println "writing out these files")))

#+end_src

* Conclusions

#+begin_quote
"The answer is inside you, but it's wrong" ~ Quelo
#+end_quote

*WWHD* (What Would Holmes Do)

* Murder or Bug

 #+ATTR_ORG: :width 150
- Both
  - can cause someone's death
  - it's hard to find the culprit


 #+ATTR_ORG: :width 150
- Bug
  - can often reproduce locally

 #+ATTR_ORG: :width 150
- Murder
  - it's often the butler

 #+REVEAL_HTML: </div>
* Put it all together

#+begin_src dot :file graph.png
digraph flow {
    data [label="Collect Data"]
    theory [label="Create Theory"]
    worked [label="did it work", shape="diamond"]
    done [label="Well done"]
    test [label="Validate theory"]

    data -> theory
    theory -> test
    test -> worked
    worked -> theory [label="No"]
    worked -> done [label="Yes"]

}
#+end_src

#+RESULTS:
[[file:graph.png]]
